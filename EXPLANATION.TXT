

---Пояснения к выполненному заданию---
Написанная мной программа-калькулятор, по сути, является LL-анализатором. Основывается она на механизме абстрактного анализатора, который напоминает по принципу работы написанный Вами абстрактный конечный автомат, но с несколькими существенными отличиями. В процессе работы данный подход оказался мне ближе и понятней, так как уже изучался мною, поэтому я решила реализовать именно его, хотя Вы, возможно, скажете, что я усложняю. Он достаточно общий, чтобы наделить калькулятор всей необходимой функциональостью.

Принцип работы абстрактного анализатора.

1. Лексер. Осуществляет преобразование из строки в поток токенов(лексем) с помощью распознавателя лексем. На данном этапе отсеиваются все неизвестные символы(если символ не распознается - ошибка распознания лексемы), а также пробелы. Лексема в этом потоке состоит из ее типа(список типов лексем - перечисление) и строкового представления.

2. Парсер(анализатор). Состоит из механизма анализатора, контекста, таблицы действий над констекстом, списка типов лексем(перечислимый тип), списка состояний контекста(перечислимый тип).
Действие над контекстом может менять или не менять его состояние, осуществлять или не осуществлять переход к следующей лексеме.
Алгоритм работы:
	а. Контекст инициализируется потоком токенов и начальным состоянием контекста
	б. Пока возможно получить состояние контекста(не достигнут конец стека состояний):
		1) Получить состояние контекста и текущую лексему.
		2) Из таблицы действий по состоянию контекста и текущей лексеме получить действие над контекстом.
		3) Выполнить полученное действие над контекстом.
	в. Получить из контекста результат работы.

На базе данного абстрактного анализатора построен конкретный анализатор - калькулятор. Для построения таблицы действий анализатора использована LL-грамматика такого вида:

E->ME'
E'->+ME'|-ME'|epsilon
M->PM'
M'->*PM'|/PM'|epsilon
P->AP'
P'->^AP"|epsilon
P"->epsilon// этот нетерминал введен для корректного синтаксического управления
A->number|(E)|function(EF')
F'->,EF'|epsilon

в грамматике устранена левая рекурсия, она левофакторизована.
Нетерминалы этой грамматики - состояния контекста калькулятора:

E=EXPRESSION,
E'=EXPRESSION_CONTINUE,
M=MULTIPLICATION_EXPRESSION,
M'=MULTIPLICATION_EXPRESSION_CONTINUE,
P=POWER_EXPRESSION,
P'=POWER_EXPRESSION_CONTINUE,
P"=POWER_EXPRESSION_END,
A=ATOM_EXPRESSION,
F'=ARGUMENT_EXPRESSION_CONTINUE

Терминалы грамматики - найденные лексемы:

число=NUMBER,
+=PLUS,
-=MINUS,
*=MULTIPLY,
/=DIVIDE,
(=BRACKET_OPEN,
)=BRACKET_CLOSE,
^=POWER,
буквенное обозначение функции=FUNCTION,
,=COMMA,
конец потока=EOF

Какие действия выполняются в каждом случае - определила из таблицы синтаксического анализа для LL-анализаторов для данной грамматики. epsilon - обычно пустое действие или применение операторов к стеку операндов.

----На данный момент реализованы:----
1. операторы сложения, вычитания, умножения, деления, возведения в степень, в том числе и дробных чисел
2. корректное вычисление выражения со скобками различной степени вложенности
3. консольный клиент для приложения.


----Выявленные недочеты реализации на данном этапе-----
1. Плохое идентифицирование возникших во время разбора и вычислений ошибок. Это можно улучшить.
2. Реализация таблицы действий кажется мне излишне громоздкой: возможно, получится немного упростить.
3. Слишком много мелких Action: на мой взгляд, необходимо создать соответствующие фабрики и упростить создание некоторых.
4. Есть возможность немного обобщить действия для операторов одного приоритета, например, создания соответствующих классов и добавления их в контекст.


-----Вопросы-----
1. Сейчас у созданного бинарного оператора можно явно просмотреть его приоритет. Хорошо ли это? На данном этапе явный приоритет необходим для корректного применения операторов при разных состояниях. Есть ли возможность сделать лучше в контексте моей реализации программы?
2. Можно ли унифицировать распознаватель лексем, чтобы распознавать все лексемы (и числа, и знаки, и идентификаторы, если их потребуется распознавать) единообразно, например, по регулярному выражению?
3. Унарный минус на данном этапе реализации не опознается. В тексте задания об этой операции ничего не сказано, но в шаге 4 говорится, что "математическое выражение может содержать вещественные числа", т.е. любые, в том числе и отрицательные. Нужно ли вводить его поддержку?


-----К следущему обновлению планирую:-----
1. Ввести поддержку вычисления функций. Добавить соответствующие тесты.
2. По возможности исправить указанные мной выше недочеты.
3. Сделать оконный интерфейс
 


  
